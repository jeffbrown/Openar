## 2 Getting Started

Currently Openar is tested on Mac OS X 10.6 (x86-64) only, and there are core functions and key bindings that assume the platform is Mac OS X.

In Openar most of the standard mouse actions and key bindings in Swing are available. Some of Openar key bindings use the META, ALT, and function keys. On Mac OS X the Command and Option keys are the META and ALT keys respectively, and depending on your keyboard you may need to hold down the Fn key when you press a function key unless you select the “Use all F1, F2, etc. keys as standard function keys” checkbox in Keyboard Preferences.

### 2.1 System Requirements

As of this writing

* Max OS X 10.6
* The Java VM used is Java HotSpot(TM) 64-Bit Server VM, version 17.1-b03-307, and Java version is 1.6.0_22.
* The versions of Clojure and contrib are both 1.2.0.
* `git` and `leiningen` commands

### 2.2 Setting Up Openar

In the following sections we call the directory where Openar repository resides *the Openar directory*. Path to Openar file is expressed relatively from the Openar directory, without the `.clj` extension unless needed. For example, `src/openar/core` means the file path *the-Openar-directory*`/src/openar/core.clj`.

Openar's source repository is on GitHub, [https://github.com/ksuzuki/Openar](https://github.com/ksuzuki/Openar). It is a leiningen project. Openar depends on leiningen to get required libraries. But it is not required to compile Openar to start it. The boot loader code is aot-compiled already and the rest of the code is compiled on-the-fly into JVM bytecode when loaded. Just download the Openar project and then run '`lein deps`' command in the Openar directory to download the dependencies. That is all you need to get ready to start Openar.

Here is an example; open Terminal and run the following commands.

		~$ git clone git://github.com/ksuzuki/Openar.git
		~$ cd Openar
		~$ lein deps

#### 2.2.1 Dependencies

This version of Openar depends on the following components.

* The Openar core system: [clojure](http://clojure.org/), [clojure-contrib](https://github.com/clojure/clojure-contrib), [swank-clojure](https://github.com/technomancy/swank-clojure/)
* UI components generated by NetBeans: [swing-layout](https://swing-layout.dev.java.net/)
* The oplix `incantea`: [incanter-core, incanter-io, incanter-charts, incanter-processing, incanter-mongodb, incanter-pdf, incanter-latex, incanter-excel](http://incanter.org/) (please visit [here](https://github.com/liebke/incanter/wiki#depends) about Incanter dependencies)
* The oplix `documenter`: [Mozilla Rhino](http://www.mozilla.org/rhino/)

### 2.3 Starting Openar

There are three ways to start Openar. In the Openar directory do one of the followings.

* Run this command from the command line.

	`java -Dfile.encoding=UTF-8 -cp src:lib/* Openar $* &>/dev/null &`

* Run the bash script `openar`, which runs the above command, from the command line.

	`sh ./openar`

* In the Finder go to the Openar directory and double-click `openar.app`. It is an executable compiled from the AppleScript file `tools/openar.scpt`, which runs the above command with your .bash_profile settings.

Normally drop `openar.app` in the Dock and start Openar just by tapping it.

Note: your `openar.app` file may not look like below in the Finder. If that is the case, see '2.10.4 Embedding the Openar Icon in openar.app'.

<p><img src="../res/ss-openar-app.png" title="openar.app" width="94" height="86" /></p>

#### 2.3.1 The .openar Directory and The Lock File

When Openar starts, it creates a directory named `.openar` (also called `dop` in the Openar code)  in the Openar directory. Openar saves bunch of files in the `dop` directory; aot-compiled oplix files, log files, oplix instance files, and temporary and trash files.

One file you should be aware of is the `lock` file in the directory `.openar/openar`. Openar creates it at startup and uses it to prevent multiple Openars starting from the same Openar directory. Openar removes the file when it quits. Remove the `lock` file manually if Openar crashed for some reason and failed to remove the file, or Openar won't start next time.

### 2.4 Oplix and The Openar

An *oplix* is an aggregate of libs providing definitions for particular Openar application. Each oplix has a main lib whose namespace name consists of the prefix `"oplix."` and the oplix name. For example, the oplix `openar` has the main lib `oplix.openar`. Likewise, the oplix `repl` has the main lib `oplix.repl`.

An *oplix instance* is a map that represents an oplix as executable entity and contains values required to execute the oplix functions. Each oplix instance has a unique name and a JFrame as the main window of the oplix instance.

When Openar starts, it opens one oplix always; the Openar. The Openar is an instance of the oplix `openar` and is special; it is a singleton oplix and you cannot close it. The Openar has two panes; the left pane lists available oplixes and the right pane lists oplix instance names with its window title. Double-clicking an oplix name in the left pane opens the oplix, and the instance name will be shown in the right pane. For example, when you double-click 'repl' in the left pane, the Openar looks like this.

![The Openar](../res/ss-the-openar.png "The Openar")

Selecting oplix names in the left pane shows their instance names in the right pane. This is how the Openar looks after opening bunch of oplixes and then selecting all oplix names in the left pane.

![The Openar](../res/ss-the-openar1.png "The Openar")

Selecting an oplix instance name in the right pane and then double-clicking it brings the instance window to the front.

### 2.5 REPL

The oplix `repl` opens a window and runs the Clojure's read-eval-print loop, or REPL for short, in it. You can open multiple REPLs. By default the REPL starts in the *user* namespace. The prompt shows the current namespace and matching parentheses on the command line will be highlighted as you type. Also wherever the caret is it comes back on the command line when you start typing.

In the REPL window there are some `repl` specific key bindings available in addition to the standard key bindings. Such as:

* the up and down arrow keys scroll back and forth command history when the caret is on the command line
* META+] moves the caret to matching parenthesis position when parentheses are highlighted
* META+; moves the caret to the beginning of the command line

You can also open a new REPL using the `repl` macro. To end the REPL and close the window, click the red close (x) button in the top-left corner of the window or press META+W.

Among `repl` instances the one named "Repl" (normally the very first `repl` instance) is special. It saves the text in the window when it closes and restores the text when it opens next time. There is no limit set for the text size currently, so it keeps growing up. Eventually you would need to clear it. To do that call the `clear-repl-content` function or its shorthand macro `crc`.

When you are get caught in long running function or infinite loop, Use CTRL+C to interrupt it and get back to the prompt.

![REPLs](../res/ss-repls.png "REPLs")

### 2.6 Ced

You can do quite a bit of stuff interactively at the REPL. But when you want to write fairly large function or edit lib and save them to file, you need a Clojure editor.

*Ced* is an oplix designed to work best in the Openar environment for editing Clojure file and developing oplix. Ced has the following features.

* Automatic indentation that is fairly close to the way Emacs in Clojure mode does
* Highlight matching parentheses
* Incremental search
* Undo/redo
* Split pane
* Hyperlink to Java API documentation
* Load and aot-compile Clojure file
* Open the oplix currently editing

To open Ced, double-click 'ced' in the left pane of the Openar. Ced opens the default scratch file `src/library/user/scratch`. The `src/library/user` directory is where you save your work files mainly.

The user interface of Ced is very simple; it consists of the main text pane and a panel in the bottom. Notice the divider with the tiny arrows in the top edge area of the text pane. From left in the bottom panel there are the Line Number field, the Column Number field, and the Find field. There is also the modification indicator at the left most edge of the panel, which turns a red asterisk when you touch file and disappears when you save the file. The window title displays Ced instance name and the file name currently editing. When the mouse cursor is in the title area, hold down the ALT+META key. The full path name of the current file pops up. (Note: on Mac OS X the Option key is the ALT key.)

![Ced](../res/ss-ced.png "Ced")

#### 2.6.1 Key Bindings and Edit Actions

In addition to the standard key bindings there are Ced specific key bindings such as:

* TAB and ENTER - automatic indentation
* META+] - move the caret to matching parenthesis position
* META+L - move the focus to the Line Number field
* META+F - move the focus to the Find field
* META+G - move the caret to the beginning of next match of the string in the Find field
* META+Z - undo edit action
* SHIFT+META+Z - redo undone action
* META+O - open a Clojure file
* META+S - save the file currently editing
* SHIFT+META+S - save the file currently editing in a different name

Normally the Line Number field displays the line number where the caret is on. But it is an editable field and you can go to line by specifying the line number in the field. Click in the field or press META+L, then specify the number and press ENTER. Pressing ESC or TAB cancels the operation and move the focus back to the text pane.

To find string, click in the Find field or press META+F and type the string you want to search for. Matching string, if any, will be highlighted as you type. Press ENTER or META+G to search next match. Keep pressing ENTER or META+G lets the search continue from the beginning of file. Press TAB to move the focus back to the text pane and then move the caret to the beginning of highlighting string. Press ESC to cancel search, move the focus back to the text pane and the caret moves back to original position. When the focus is in the text pane, pressing META+G moves the caret to the beginning of next match of the string in the Find field.

#### 2.6.2 Editing and Loading File: An Example

When you want to try out a Clojure code quickly, you would take the following steps in most cases.

1. Open REPL and Ced by double-clicking the names in the Openar. When you open Ced from the Openar, Ced opens the default scratch file.

2. In the Ced window type:  
  
	>(in-ns 'user)  
	>(defn ask [] (println "are we there yet?"))  
  
	Notice the modification indicator is on (displaying a red asterisk).

3. Press META+S to save the file. The red asterisk is now gone.

4. Then press F2. This lets Ced load the file so that the `ask` function will be defined in the `user` namespace.

5. Call the `ask` function at the REPL and see it prints the string.

#### 2.6.3 Opening and Saving File

To open Clojure file in Ced, press META+O and use the Open Openar File dialog box.

You can also open file in Ced at the REPL using the `ced` macro. The macro can take a file path or a java.io.File and optional line number as arguments.

File path can be either in symbol or string. When it's a symbol, it doesn't need to be quoted and period to slash and hypen to underscore translations are applied. Then a lib file corresponding the symbol in the `src` directory is looked up. Try the followings at the REPL. To open the default scratch file:

		(ced library.user.scratch)

To open the Openar's `oplix` lib file and move to line 203:

		(ced openar.oplix 203)

When you want to open an oplix lib file you can abbreviate `oplix`. For example, this opens the `core` file of the oplix `repl`.

		(ced repl.core)

The symbol has to begin with `oplix` only when you want to open an oplix lib file whose name begins with `openar`. For example,

		(ced oplix.openar.lists)

When the path is a string, it should be an absolute path or a relative path from the current Openar directory. When the argument is a java.io.File, it's taken as is. Either way you don't need to add the `.clj` extension. When the specified file doesn't exist or no argument is given, Ced falls back to open the default scratch file.

To save the file currently editing just press META+S. When you want to save file in different name, press SHIFT+META+S and use the Save As Openar File dialog box. You don't need to add `.clj` extension to the file name; Ced adds it for you. Also Ced applies the translations from period to slash and hyphen to underscore to file path when saving and does the other way around when opening.

#### 2.6.3 Browsing Libraries

You can also use Ced to browse libraries. For example, if you want to see how the `println` function is implemented, type this at the REPL.

>`(ced #'println)`

What happens then is that 1) the values under the `:file` and `:line` keys of the `println` var metadata are looked up, 2) figure out the location of the file `core.clj` based on the `:file` value and extract it from `clojure.jar`, 3) save the file to `src/library/clojure` directory, and 4) open Ced with the file path and the line number where the `println` function is defined.

![Ced](../res/ss-ced1.png "Ced")

### 2.7 The Log-viewer and Exceptor

The Clojure's `repl` function takes care of exception thrown in the REPL; it catches the exception and prints the summaries. The `repl` function of the oplix `repl`, in turn, captures output data to the standard output and error streams and displays it in the REPL window, so you can see the exception message and summaries. For exceptions thrown outside of the REPL, Openar has a logging facility to catch it and save the messages to log file. Openar also captures output data written to the *System/out* and *System/err* streams and saves it to log file.

You can see the content of the current log file using the *Log-viewer*, an instance of the singleton oplix `log-viewer`.

Whenever an exception is reported, the logging facility looks for the exception listeners registered to the logging facility and calls them with the exception object. Exceptor (the oplix *`exceptor`*) is one oplix using this feature. Given an exception object Exceptor does:

1. open a window in the bottom-right corner of the display and show the detail message of the exception in the window, and
2. when it is possible to figure out the location where the exception is thrown, open Ced with the location information.

Here is an example. Open Ced and write the code below exactly as shown:

		(in-ns 'user)

		(defn pangram
		  []
		  (let [s "The quick brown fox"
		        v "jumps over"
		        o "the lazy dog"]
		    [s v c]))

		(defn print-pangram
		  []
		  (apply println (pangram)))

For demonstration purpose, make sure to put the caret at the end of the last line. Now press F2 to load the file in the `user` namespace and then, oops! an Exceptor window is opened with a message. The message says there is a symbol that cannot be resolved at line 5. Click the Ced window and bring it to the font. Make sure to click in the window title, not the text pane, so that you can see the caret is set at the beginning of line 5 where the error message is pointing out as the error line. Open the Log-viewer and you can also see the stack trace of the exception is logged.

![Log-viewer and Exceptor](../res/ss-lv-and-exceptor.png "Log-viewer and Exceptor")

Exceptor can handle runtime exception similarly so that you can get to the point where it is OK syntactically but crashes when evaluated. Let's fix the syntax error and introduce a runtime error in the above code.

		(ns library.user.scratch)

		(defn pangram
		  []
		  (let [s "The quick brown fox"
		        v "jumps over"
		        o "the lazy dog"]
		    (s v o)))

		(defn print-pangram
		  []
		  (apply println (pangram)))

Notice the symbol 'c' is referenced correctly but a vector with 's', 'v', 'c' is turned into a list. Now the code doesn't have any syntax error but fails to return from the `pangram` function because 's' is not a function but a string. Notice also that the first line is changed so that the code is loaded as the lib `library.user.scratch`. It's because Exceptor handles runtime exception only when Openar lib is involved in the exception stack.

Load the lib by pressing F2. This time you don't get compiler exception. Then close the Ced, open the REPL, and call the `print-pangram` function like this:

> `(invoke-later #(library.user.scratch/print-pangram))`

What the heck is the `invoke-later` function and why is it used? Recall the Clojure's `repl` function takes care of exception, that is, exception thrown in the REPL will be caught and handled by the REPL so that the Openar's logging facility can't catch and hand it over to Exceptor. The `invoke-later` function is an Openar function that takes a body of expressions and post it to the event dispatch thread of the current oplix instance. The body will then be evaluated later in a try-catch form which in turn calls an Openar's logging function if exception is thrown while evaluating the body.

This way you get two windows when you call the above function; one is an Exceptor window with the message pointing the error line and the other is a Ced window in that the file `library.user.scratch` is opened and the caret is set at the beginning of the error line.

![Ced and Exceptor](../res/ss-ced-and-exceptor.png "Ced and Exceptor")

Change the list in the line back to the vector to fix the error, and press F2. Then call the `invoke-later` function above again. This time it will print the pangram correctly (after the prompt, and that is what is supposed to happen. You can continue typing as though nothing is there or press ENTER to get a new prompt).

#### 2.7.1 The Logging Functions and The lg Macro

The `log-info` function is one of the Openar's logging functions. It takes variable arguments and prints them to log file. Simply put, it is a `print-str` function printing to log file. The `lg` macro is a shorthand of the `log-info` function and is useful when debugging code.

Open the Log-viewer and try these at the REPL.

>`(log-info nil)`  
>`(lg 1 2 3)`  
>`(lg "Openar name:" (get-openar-name) "Openar version:" (get-openar-version))`  

### 2.8 API-browser

API-browser (the oplix `api-browser`) searches an API document URL using a keyword and open the URL in the default system browser. It opens a small popup window for a very short time only when it didn't find URL in order to indicate the failure.

Currently API-browser accepts only a Java class or interface name as lookup keyword (letter case is ignored) and searches API document URL of Java SE 6 and EE 6.

You can call API-browser at the REPL using the `browse-api` macro or its shorthand `ba`. For example:

> `(browse-api jframe)`  
> `(ba string)`  
> `(ba element)`

In the last case you will get two document pages about `Element`; one is about `javax.xml.bind.Element` of Java SE 6 and the other is about `javax.lang.model.element.Element` of Java EE 6. Give a fully qualified class/interface name if you want to be specific and get just one page. For example:

> `(ba javax.xml.bind.Element)`

Also, when you want to use a nested class name, such as `HTML.Tag` of the `javax.swing.text.html` package, use '$' instead of '.' in the class name like `html$tag`.

Ced also knows how to call API-browser. For example, open Ced and type the following lines:

		(import '(javax.swing.text Segment)
		        'javax.swing.text.html.HTML$Tag)

Put the caret on "`Segment`" and press F1. Likewise, put the caret on "`javax.swing.text.html.HTML$Tag`" and press F1. You will get the document pages of `Segment` and `HTML$Tag` in the browser.

### 2.9 Quitting Openar

To quit Openar, press META+Q or choose Openar > Quit Openar from the Openar menu.

Openar remembers running oplix instances when quitting and tries to open them at next startup. Oplixes are given a chance to save instance data to file when closing and load it back when opening. So, for example, when you quit Opener while the Openar and the Repl are running, you will see them reappear at the same location when Openar starts next time.

### 2.10 Tips

#### 2.10.1 Global Keyboard Shortcuts

* META+W: most of oplixes accept META+W as the window close action.

* META+\`: by default META+\` (the "backquote" key) is taken by Mac OS X and it brings next *visible* window to the font *immediately*. But any minimized windows are ignored. When you disable the keyboard shortcut "Move focus to next window in application" in Keyboard Preferences, Openar takes over the key and behaves differently. In stead of bringing up next visible window to the front immediately, a small popup window shows up in next window's top-left corner with the window's title. Even if next window is minimized, the popup window still appears as though the window is visible at the location. Release the key when you find the window you are looking for, then the window comes to the font, restoring it if it was minimized. Press SHIFT+META+\` to move on backward and META+ESC to cancel the operation and stay with the current window.

#### 2.10.2 The Trash Directory

Most of oplixes are designed to move old copy of file into the directory `.openar/trash` before updating or deleting the file so that you may be able to retrieve most recently updated/deleted file from there.

#### 2.10.3 UTF-8 File Encoding

Openar uses UTF-8 as file encoding.

#### 2.10.4 Embedding the Openar Icon in openar.app

Your `openar.app` file may not look like this in the Finder.

<p><img src="../res/ss-openar-app.png" title="openar.app" width="94" height="86" /></p>

You can embed the Openar icon in your `openar.app` file and make it look like above.

1. In the Finder go to the `tools` directory and open the file `openar-icon.icns` to see the Openar icons in Preview.

2. In Preview choose Edit > Select All and then Edit > Copy.

3. Go back to the Finder and select `openar.app`. Then choose File > Get Info.

4. At the top of the `openar.app` Info window, click the picture of the icon to select it, and then choose Edit > Paste.
